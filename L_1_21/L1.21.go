package main

import (
	"log"
)

//Реализовать паттерн проектирования «Адаптер» на любом примере.
//Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.
//Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по
//интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.
//Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

//1. Клиент (Computer): Наша система, которая умеет работать с устройствами, подключаемыми через порт USB-C. Она ожидает
//интерфейс USBCPort.
//2. Адаптируемый объект (LegacyPrinter): Старый принтер, у которого есть только устаревший параллельный
//порт (LPT). У него есть метод PrintWithLPT.
//3. Адаптер (LPTToUSBAdapter): переходник, который будет реализовывать интерфейс USBCPort, а внутри
//себя вызывать метод PrintWithLPT у старого принтера.

// USBCPort - это интерфейс, который наша система (клиент) умеет использовать.
type USBCPort interface {
	ConnectWithUSBC()
}

// Computer - имеет метод для подключения устройств через USB-C
type Computer struct{}

// InsertIntoUSBCPort - метод компьютера, которая принимает любое устройство, реализующее интерфейс USBCPort.
func (c *Computer) InsertIntoUSBCPort(device USBCPort) {
	log.Printf("Computer: Inserting device into USB-C port.")
	device.ConnectWithUSBC()
}

// LegacyPrinter - старый принтер
type LegacyPrinter struct{}

// PrintWithLPT - собственный метод старого принтера, несовместимый с USBCPort
func (p *LegacyPrinter) PrintWithLPT(text string) {
	log.Printf("LegacyPrinter: Printing '%s' via LPT port.", text)
}

// LPTToUSBAdapter - адаптер, который "оборачивает" LegacyPrinter
type LPTToUSBAdapter struct {
	printer     *LegacyPrinter // ссылка на адаптируемый объект
	textToPrint string         // данные, которые нужно передать
}

// ConnectWithUSBC - метод адаптера, который реализует целевой интерфейс USBCPort,
// внутри себя он преобразует запрос от компьютера в запрос к старому принтеру
func (a *LPTToUSBAdapter) ConnectWithUSBC() {
	log.Println("Adapter: Converting USB-C signal to LPT signal.")
	a.printer.PrintWithLPT(a.textToPrint)
}

func main() {
	computer := &Computer{}
	legacyPrinter := &LegacyPrinter{}

	// Создаем адаптер. Компьютер ничего не знает о legacyPrinter
	adapter := &LPTToUSBAdapter{
		printer:     legacyPrinter,
		textToPrint: "Hello from Adapter Pattern!",
	}

	// computer работает с адаптером так же, как с любым другим устройством, совместимым с USB-C
	computer.InsertIntoUSBCPort(adapter)
}

// Применимость паттерна:
// 1. Интеграция с легаси-кодом.
// 2. Работа со сторонней библиотекой. Функционал библиотеки отличается от функционала библиотеки, поэтому чтобы не делать
//костыли по всему проекту лучше сделать адаптер.
// 3. Когда есть несколько классов со схожей функциональностью, можно сделать адаптер и работать через него одинаковым образом
//со всеми классами.

// Плюсы:
// 1. Скрытие логики: клиент ничего не знает о реализации конкретных классов.
// 2. Можно переиспользовать старый код, не переписывая его полностью.
// 3. Принцип единой ответственности: логика адаптера выносится в отдельный класс, а код клиента и адаптируемого класса
//это никак не затрагивает.

// Минус: введение дополнительного слоя абстракции, что усложняет код.

// Реальные примеры использования:
// 1. При работе с БД единые методы преобразуются конктретными драйверами в команды, специфичные для конкретной БД (Postgres, MySQL)
// 2. Адаптер при работе сервиса с данными в формате json с другим сервисом, который использует SOAP.
// 3. Можно сделать адаптер под какую-либо систему логирования (например, zap), а в приложении использовать более простой
//интерфейс для логов. При переезде на другую систему логирования нужно будет переделать только адаптер.
